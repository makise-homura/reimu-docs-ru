# Интеграция ПО REIMU

## Требования к аппаратному обеспечению

* Микросхема BMC — AST2400 или AST2500.
* В качестве флеш-памяти для основной прошивки должна использоваться SPI NOR-память размера 32 или 64 МБ.
* UART2 (ttyS1) или UART5 (ttyS4) менеджера должен быть доступен пользователю.
* Должна быть доступна SPI NOR-память программы начального старта платформы с помощью управляемого линией `SPI_MNGR_CONNECT` ключа (при `SPI_MNGR_CONNECT == 1` эта микросхема не должна быть подключена ни к какому другому SPI-мастеру).
* UART1 (ttyS0) менеджера должен быть соединён с платформой для обеспечения протокола Serial-on-LAN.

## Таблица назначения GPIO

Наиболее актуальная таблица назначения GPIO указана в файлах `/etc/gpiotab/*` на BMC:

* `gpiotab.common`: GPIO-линии, общие для всех устройств.
* `gpiotab.2400`: GPIO-линии для устройств на базе AST2400.
* `gpiotab.2500`: GPIO-линии для устройств на базе AST2500.
* `gpiotab.2600`: GPIO-линии для устройств на базе AST2600.

Далее приведена краткая сводка GPIO. В колонке «направление» указан не электрический источник сигнала, а устройство, инициирующее передачу. Здесь BMC — это BMC, PL — платформа. В колонке "Линия GPIO" в скобках указаны линии для AST2600, если они отличаются от линий для AST2400 и AST2500.

| Обозначение                 | Направление | Назначение                                | Линия GPIO  |
|:--------------------------- |:-----------:|:----------------------------------------- |:-----------:|
| GPIO_PWR_BTN                | BMC&rarr;PL | Кнопка POWER платформы                    |   N5 (V5)   |
| GPIO_RST_BTN                | BMC&rarr;PL | Кнопка RESET платформы                    |      P3     |
| GPIO_RESET_IN               | BMC&larr;PL | Сигнал «платформа под сбросом»            |      O3     |
| GPIO_POWER_IN               | BMC&larr;PL | Сигнал «платформа под питанием»           |      O2     |
| GPIO_INTRUSION              | BMC&larr;PL | Сигнал датчика вскрытия корпуса платформы |      R0     |
| GPIO_ACT_LED                | BMC&rarr;PL | Светодиод «BMC работает»                  |      O6     |
| GPIO_BOOT_LED               | BMC&rarr;PL | Светодиод «BMC загружается»               |      G1     |
| GPIO_APMDZ_LED              | BMC&larr;PL | Сигнал от АПМДЗ платформы                 |      F3     |
| GPIO_ALERT_1                | BMC&larr;PL | Один из сигналов ALERT платформы          |      B0     |
| GPIO_ALERT_2                | BMC&larr;PL | Один из сигналов ALERT платформы          |      B5     |
| GPIO_ALERT_3                | BMC&larr;PL | Один из сигналов ALERT платформы          |      B6     |
| GPIO_ALERT_4                | BMC&larr;PL | Один из сигналов ALERT платформы          |      B2     |
| GPIO_ALERT_5                | BMC&larr;PL | Один из сигналов ALERT платформы          |      B3     |
| GPIO_ALERT_6                | BMC&larr;PL | Один из сигналов ALERT платформы          |      B1     |
| GPIO_ALERT_7                | BMC&larr;PL | Один из сигналов ALERT платформы          |      B7     |
| GPIO_MB_ID0                 | BMC&larr;PL | Идентификация платформы                   |      Y0     |
| GPIO_MB_ID1                 | BMC&larr;PL | Идентификация платформы                   |      Y1     |
| GPIO_MB_ID2                 | BMC&larr;PL | Идентификация платформы                   |      Y2     |
| GPIO_MB_ID3                 | BMC&larr;PL | Идентификация платформы                   |      Y3     |
| GPIO_SPI_CONNECT            | BMC&rarr;PL | Подключение SPI памяти платформы          |      O0     |
| **На платформах без CPLD:** |             |                                           |             |
| GPIO_UID_BTN                | BMC&larr;PL | Кнопка UID платформы                      |   N3 (V3)   |
| GPIO_UID_LED                | BMC&rarr;PL | Светодиод UID платформы                   |   N4 (V4)   |
| GPIO_SYS_FAIL1_LED          | BMC&rarr;PL | Светодиод SYS FAIL 1 платформы            |      C2     |
| GPIO_SYS_FAIL2_LED          | BMC&rarr;PL | Светодиод SYS FAIL 2 платформы            |      C7     |
| GPIO_PWR_FAIL_LED           | BMC&rarr;PL | Светодиод POWER FAIL платформы            |      A3     |
| GPIO_OH_FF1_LED             | BMC&rarr;PL | Светодиод OVERHEAT/FAN FAIL 1 платформы   |      A2     |
| GPIO_OH_FF2_LED             | BMC&rarr;PL | Светодиод OVERHEAT/FAN FAIL 2 платформы   |      Q6     |
| GPIO_FAN_FAIL_LED           | BMC&rarr;PL | Светодиод FAN FAIL платформы              |      C6     |
| GPIO_OVERHEAT_LED           | BMC&rarr;PL | Светодиод OVERHEAT платформы              |      C3     |
| GPIO_ALARM_LED              | BMC&rarr;PL | Светодиод ALARM платформы                 |      G0     |
| **На платформах c CPLD:**   |             |                                           |             |
| GPIO_UID_BTN                | BMC&rarr;PL | Кнопка UID платформы                      |   N3 (V3)   |
| GPIO_UID_LED                | BMC&larr;PL | Состояние UID платформы                   |   N4 (V4)   |
| GPIO_TINYSPI_CS             | BMC&rarr;PL | Канал связи с CPLD                        |   N2 (V2)   |
| GPIO_TINYSPI_IO             | BMC&rarr;PL | Канал связи с CPLD                        |   N1 (V1)   |
| GPIO_TINYSPI_CLK            | BMC&rarr;PL | Канал связи с CPLD                        |   N0 (V0)   |
| GPIO_TINYSPI_ALERT          | BMC&larr;PL | Сигнал «CPLD изменила состояние»          |   N6 (V6)   |

### Пины GPIO_MB_ID

При наличии на платформе CPLD, связанной с BMC по протоколу TinySPI, все 4 пина `GPIO_MB_ID` должны находиться в высоком уровне.

Любое другое состояние этих пинов интерпретируется как отсутствие CPLD.

## Данные, описывающие платформу

### Память программы начального старта

В ПЗУ программы начального старта должно находиться описание устройств платформы в формате flattened device tree (DTB).

В случае наличия в ПЗУ таблицы разделов device tree должно находиться в соответствующем разделе; иначе начиная с адреса 7 МБ.

В device tree должен находиться блок (node) с адресом `/bmc`, внутри которого могут находиться следующие свойства (properties) и блоки (nodes):

* свойство `compatible = "mcst,флавор";`, здесь вместо «`флавор`» надо подставить название флавора прошивки. Это свойство не используется BMC и имеет только информативное значение.
* свойство `tinyspi;` — должно быть указано для платформ с CPLD.
* свойства `i2c0`..`i2c13` (`i2c0`..`i2c15` в будущем для AST2600) — ссылки на блоки, описывающиы I²C-шины и устройства на них, доступные BMC. Некоторые из ссылок могут отсутствовать. FRU ID EEPROM, RTC и т.п. должны находиться на этих шинах.
* блоки `alert1`..`alert7` — блоки, задающие пристутствующие в платформе сигналы ALERT и их названия (в параметре `label` внутри этих блоков). Некоторые из блоков могут отсутствовать.
* блок `intrusion` — блок, задающий пристутствующий в платформе сигнал вскрытия корпуса и его полярность (в параметре `polarity` внутри этого блока: `no` — 0 при закрытой крышке, `nс` — 1 при закрытой крышке). Блок может отсутствовать.

Пример подобного описания (без описания блоков, соответствующих шинам I²C):

```
    bmc {
        compatible = "mcst,reimu-5564";

        i2c3 = &i2c_pmbus;
        i2c4 = &i2c_fruid;
        i2c5 = &i2c_mntr;
        i2c7 = &i2c_cpu;
        i2c8 = &i2c_pci;

        alert1 {
            label = "CPU overheat";
        };

        alert6 {
            label = "SMBus critical overheat";
        };

        intrusion {
            polarity = "nc";
        };
    };
```

При отстутствии такого описания или отсутствии device tree в ПЗУ программы начального старта FRUID EEPROM ищется на шине `i2c5` с адресом `0x57`.

### FRUID EEPROM

На платформе должна иметься FRU ID EEPROM (24С128 или совместимая), описанная в device tree платформы следующим образом:

```
    eeprom@57 {
        compatible = "atmel,24c128";
        reg = <0x57>;
        label = "FRUID";
    };
```

Признак, по которому определяется, что это микросхема FRU ID — это значение «`FRUID`» параметра `label`.

При отстутствии такого описания или отсутствии device tree в ПЗУ программы начального старта FRUID EEPROM ищется на шине `i2c5` с адресом `0x57`.

### RTC платформы

Для хранения времени при отключенном дежурном питании платформы на платформе должна иметься микросхема I²C RTC (MCP7940x или совместимая), описанная в device tree платформы следующим образом:

```
    mcp7940@6f {
        compatible = "microchip,mcp7940x";
        reg = <0x6f>;
        label = "platform";
    };
```

Признак, по которому определяется, что это микросхема RTC платформы — это значение «`platform`» параметра `label`.

При отстутствии такого описания или отсутствии device tree в ПЗУ программы начального старта считается, что RTC платформы отсутствует, и при включении дежурного питания время BMC устанавливается на 1 января 1970 года.

### Датчики

Термодатчики, имеющиеся на доступных BMC шинах, могут быть описаны следующим образом:

* Блок, описывающий микросхему, может называться как угодно.
* Параметр `compatible` у этого блока должен оканчиваться на имя поддерживаемого драйвера. На данный момент поддерживаются `lm96163`, `pmbus`, `l_pcs_i2c`.
* Параметр `reg` у этого блока должен быть равен slave-адресу микросхемы.
* Параметр `status` у этого блока может присутствовать и, если присутствует, должен иметь значение, отличное от `disabled`. Если его установить в `disabled`, то микросхема будет игнорироваться BMC (в таком случае её описание может быть воспринято ОС платформы, но не BMC); это рекомендуется сделать для всех микросхем, ни один датчик на которых не должен отслеживаться из BMC.
* Параметр `label` у этого блока должен обозначать эту конкретную микросхему целиком, например, `CPU FAN Control` или `AUX Power Supply`.
* Этот блок должен содержать один или более блоков (далее — блок сенсора), названных `тип@номер`, где `тип` — тип датчика hwmon (поддерживаются `fan`, `temp`, `in`, `curr`, `power`), а номер — номер этого датчика в каталоге `hwmon`. Например, если мы анализируем показания из файла `temp1_input`, блок должен называться `temp@1`; если из `curr0_input` — то `curr@0` и т.п.
* Параметр `reg` у блока сенсора всегда должен быть равен номеру датчика (тот же, что и в названии блока).
* Параметр `label` у блока сенсора должен обозначать этот датчик в микросхеме (например, `Fan`, `Ambient`, `+12V`, `Total` и т.п.)
* Параметр `status` у блока сенсора должен иметь значение `okay`. Если его установить в `disabled`, то датчик будет игнорироваться BMC (в таком случае описание датчика будет иметь чисто информативную нагрузку, однако сама микросхема будет инстанцироваться).
* В блоке сенсора могут быть указаны значения `min_alert` и/или `max_alert`; при их достижении показаниями сенсора будет считаться, что его показания требуют внимания (состояние Alert).
* В блоке сенсора могут быть указаны значения `min_crit` и/или `max_crit`; при их достижении показаниями сенсора будет считаться, что его показания сигнализируют об отказе оборудования (состояние Critical).
* Не рекомендуется указывать значение `"0"`: при выключении питания сенсор может выдать такое значение, и это будет расценено, как переход в состояние Alert или Critical.
* Все предельные значения — строки, а не числа. У блока `fan` предельные значения указываются в RPM, у `temp` — в миллиградусах Цельсия, у `in` — в милливольтах, `curr` — в миллиамперах, `power` — в микроваттах.

Пример описания для микросхемы LM96163 (датчики на которой должны отслеживаться BMC):

```
    lm96163@4c {
        compatible = "national,lm96163";
        reg = <0x4c>;
        status = "okay";
        label = "CPU FAN Control";
        #address-cells = <0x1>;
        #size-cells = <0x0>;

        fan@1 {
            reg = <0x1>;
            label = "Fan";
            status = "okay";
            min_alert = "200";
        };

        temp@1 {
            reg = <0x1>;
            label = "Ambient";
            status = "okay";
            min_crit = "-40000";
            min_alert = "-10000";
            max_alert = "50000";
            max_crit = "80000";
        };

        temp@2 {
            reg = <0x2>;
            label = "not connected";
            status = "disabled";
        };
    };
```

Важно: по спецификации D-Bus параметры `label` в любых из перечисленных блоков не должны включать символы, отличные от латинских алфавитно-цифровых и символа подчёркивания. Все прочие символы будут интерпретированы как символ подчёркивания (который будет преобразован в пробел при отображении датчиков в web-интерфейсе).

#### Термодатчики процессоров

Термодатчики процессоров Эльбрус-8С или Эльбрус-8СВ, находящиеся на шине `MNTR`, должны быть описаны в device tree платформы следующим образом:

```
    pcs@27 {
        compatible = "mcst,l_pcs_i2c";
        reg = <0x27>;
        label = "CPU 0";
        #address-cells = <0x1>;
        #size-cells = <0x0>;

        temp@1 {
            reg = <0x1>;
            label = "MC 0, MC 1";
            status = "okay";
            min_crit = "-40000";
            min_alert = "-10000";
            max_alert = "85000";
            max_crit = "90000";
        };
    };

```

Важные детали:

* Блок, названный здесь `pcs@1` (далее блок `pcs`), может называться как угодно.
* Параметр `compatible` у блока `pcs` всегда должен быть равен `mcst,l_pcs_i2c`.
* Параметр `reg` у блока `pcs` должен быть равен slave-адресу датчика (см. ниже).
* Параметр `label` у блока `pcs` должен обозначать конкретный процессор, например, `CPU 0` или `BSP CPU`.
* Блок `pcs` должен содержать один блок, названный `temp@1` (далее блок `temp`).
* Параметр `reg` у блока `temp` всегда должен быть равен 1.
* Параметр `label` у блока `temp` должен обозначать конкретный датчик процессора (см. таблицу ниже).
* На каждый из процессоров Эльбрус-8С должно иметься 8 блоков `pcs`; на каждый из процессоров Эльбрус-8СВ должно иметься 7 блоков `pcs`.

Slave-адрес каждого датчика кодирует старшим полубайтом номер процессора (0x2 — CPU0, 0x3 — CPU1, 0x4 — CPU2, 0x5 — CPU3), а младшим — номер сенсора (см. таблицу ниже).

Рекомендуемые значения параметров `label` для процессора Эльбрус-8С:

| Сенсор | Параметр `label` |
|:------:| ---------------- |
|   0    | `Core 1`         |
|   1    | `Core 0, Core 2` |
|   2    | `Core 3`         |
|   3    | `Core 5`         |
|   4    | `Core 4, Core 6` |
|   5    | `Core 7`         |
|   6    | `MC 2, MC 3`     |
|   7    | `MC 0, MC 1`     |

Рекомендуемые значения параметров `label` для процессора Эльбрус-8СВ:

| Сенсор | Параметр `label` |
|:------:| ---------------- |
|   0    | `Core 0, Core 1` |
|   1    | `Core 2, Core 3` |
|   2    | `Core 4, Core 5` |
|   3    | `Core 6, Core 7` |
|   4    | `MC 0, MC 1`     |
|   5    | `MC 2, MC 3`     |
|   6    | `SIC 0`          |

### Индикатор POST кодов

На платформе могут иметься две микросхемы GPIO-расширителей (MCP23017 или совместимые), описанные в device tree платформы следующим образом:

```
    pca9534@20 {
        compatible = "microchip,mcp23017";
        reg = <0x20>;
        label = "postcode";
    };
    pca9534@21 {
        compatible = "microchip,mcp23017";
        reg = <0x21>;
        label = "health";
    };
```

Микросхема, обозначенная как «`postcode`» в параметре `label` считается содержащей POST-коды (их туда пишет программа начального старта или ОС платформы).

Микросхема, обозначенная как «`health`» в параметре `label` считается применяемой для управления Health LED платформы.

При отстутствии такого описания или отсутствии device tree в ПЗУ программы начального старта считается, что Health LED на платформе отсутствует, а POST-коды не определены.

Назначение битов GPIO-расширителей (0 — активный уровень, 1 — неактивный):

| Бит         | Назначение                           |
| ----------- | ------------------------------------ |
| postcode:0  | Сегмент E младшего разряда POST-кода |
| postcode:1  | Сегмент D младшего разряда POST-кода |
| postcode:2  | Сегмент C младшего разряда POST-кода |
| postcode:3  | Сегмент H младшего разряда POST-кода |
| postcode:4  | Сегмент B младшего разряда POST-кода |
| postcode:5  | Сегмент A младшего разряда POST-кода |
| postcode:6  | Сегмент D младшего разряда POST-кода |
| postcode:7  | Сегмент F младшего разряда POST-кода |
| postcode:8  | Сегмент E cтаршего разряда POST-кода |
| postcode:9  | Сегмент D cтаршего разряда POST-кода |
| postcode:10 | Сегмент C cтаршего разряда POST-кода |
| postcode:11 | Сегмент H cтаршего разряда POST-кода |
| postcode:12 | Сегмент B cтаршего разряда POST-кода |
| postcode:13 | Сегмент A cтаршего разряда POST-кода |
| postcode:14 | Сегмент G cтаршего разряда POST-кода |
| postcode:15 | Сегмент F cтаршего разряда POST-кода |
| health:8    | Синий кристалл светодиода Health     |
| health:9    | Зелёный кристалл светодиода Health   |
| health:10   | Красный кристалл светодиода Health   |

Прочие биты не используются.

Расположение сегментов семисегментных индикаторов:

```
  AAAA
F      B
F      B
  GGGG
E      C
E      C
  DDDD   H

```

## Запуск образа REIMU под эмулятором

В крайне ограниченном режиме возможно запустить образ REIMU под добработанным эмулятором QEMU. Это может быть удобно в случае отладки запуска U-Boot, ядра и т.п. Разумеется, никакой функционал, завязанный на GPIO, FRU ID, device tree платформы и т.п. работать не будет.

### Подготовка образа Reimu

При сборке образа для эмулятора рекомендуется удалить пакет `revert-to-mfg` из добавляемых в образ (отредактировав файл `meta-mcst/meta-common/recipes-phosphor/images/obmc-phosphor-image.bbappend`), иначе это приведёт к циклической перезагрузке (для эмулятора кнопка UID выглядит всегда нажатой).

### Скачивание последней версии QEMU
  ```
  wget https://jenkins.openbmc.org/job/latest-qemu-x86/lastSuccessfulBuild/artifact/qemu/build/qemu-system-arm
  chmod u+x qemu-system-arm
  ```
### Запуск образа

 1. Задать путь к образу (который получается при сборке в виде файла `*.static.mtd`)
    ```
    IMAGE=/path/to/image/obmc-phosphor-image-reimu-XXXX.static.mtd
    ```
 2. Если мы находимся в каталоге со скачанным исполняемым файлом qemu, то можно запустить эмуляцию подобной командой
 	- для `reimu-4232m` и `reimu-4232`
        ```
        ./qemu-system-arm -M supermicrox11-bmc -nographic -drive file=$IMAGE,format=raw,if=mtd -net nic -net user,hostfwd=:127.0.0.1:2222-:22,hostfwd=:127.0.0.1:2443-:443,hostfwd=udp:127.0.0.1:2623-:623,hostname=qemu
        ```
        Для корректного отображения в консоли, при каждой загрузке необходимо останавливать U-Boot нажатием клавиши пробела (для появления приглашения `ast#`) и продолжать загрузку последующим вводом команд:
        ```
        setenv bootargs console=ttyS4,115200n8 root=/dev/ram rw
        boot
        ```
    - для `reimu-4532`
        ```
        ./qemu-system-arm -M supermicrox11-bmc -nographic -drive file=$IMAGE,format=raw,if=mtd -net nic -net user,hostfwd=:127.0.0.1:2222-:22,hostfwd=:127.0.0.1:2443-:443,hostfwd=udp:127.0.0.1:2623-:623,hostname=qemu
        ```
    - для `reimu-4564`
        ```
        ./qemu-system-arm -M supermicrox11-bmc,fmc-model=n25q512a -nographic -drive file=$IMAGE,format=raw,if=mtd -net nic -net user,hostfwd=:127.0.0.1:2222-:22,hostfwd=:127.0.0.1:2443-:443,hostfwd=udp:127.0.0.1:2623-:623,hostname=qemu
        ```
    - для `reimu-5564`
        ```
        ./qemu-system-arm -m 512 -M ast2500-evb,fmc-model=n25q512a -nographic -drive file=$IMAGE,format=raw,if=mtd -net nic -net user,hostfwd=:127.0.0.1:2222-:22,hostfwd=:127.0.0.1:2443-:443,hostfwd=udp:127.0.0.1:2623-:623,hostname=qemu
        ```
    - для `reimu-6564`
        ```
        ./qemu-system-arm -m 512 -M ast2600-evb,fmc-model=n25q512a -nographic -drive file=$IMAGE,format=raw,if=mtd -net nic -net user,hostfwd=:127.0.0.1:2222-:22,hostfwd=:127.0.0.1:2443-:443,hostfwd=udp:127.0.0.1:2623-:623,hostname=qemu
        ```

    Где
    - `hostfwd=:127.0.0.1:2222-:22` - проброс 22 порта на 2222 для подключения по ssh
    - `hostfwd=:127.0.0.1:2443-:443` - проброс 443 порта на 2443 для подключения по https
    - `hostfwd=udp:127.0.0.1:2623-:623` - проброс 623 порта на 2623 для подключения по ipmi 

Следует понимать, что в процессе работы некоторые части образа (переменные U-Boot, раздел с пользовательскими данными) могут изменяться. Поэтому эксперименты стоит проводить на копии собранного образа, чтобы его не испортить.

Эмуляцию можно прервать нажав `ctrl+a x` в консоли.

## Перспективы добавления нового ПО в образ

Ниже приведены размеры в килобайтах резервов свободного места в различных областях образа у каждого флавора. Значения примерные.

| Флавор  | U-Boot  | Ядро  | SQUASHFS |
|:-------:|:-------:|:-----:|:--------:|
|  4232M  |    28   |  213  |   3184   |
|  4232   |    28   |  209  |   3172   |
|  4264   |   668   |  825  |   2016   |
|  4564   |   668   |  826  |   2020   |
|  5564   |   670   |  635  |   1636   |
|  6564M  |   304   |  320  |   1556   |

Раздел U-Boot с точки зрения системы сборки содержит также и место под раздел параметров U-Boot размером 128 килобайт (см. файл `tmp/work/reimu_*/obmc-phosphor-image/1.0-r0/temp/log.do_generate_static` в каталоге сборки), поэтому важно следить за тем, чтобы реальный размер записанного в него U-Boot был меньше допустимого значения (`available`) на не менее, чем 131072 байта (`margin`). В таблице эти данные приведены уже с учётом размера раздела параметров (т.е. при значении в 28 килобайт в файле лога запас будет показан в 156 килобайт).
